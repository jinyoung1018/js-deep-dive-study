# 25장 클래스

## **25.1 클래스는 프로토타입의 문법적 설탕인가?**

- 자바스크립트는 프로토타입 기반의 객체지향 언어다.
- 프로토타입 기반 언어는 클래스 없이도 객체지향적 상속을 구현할 수 있다.
- ES5에서는 생성자 함수와 프로토타입을 사용해 이를 구현했다.
- ES6의 클래스는 프로토타입 기반의 객체지향 모델을 간소화하면서도, 클래스 기반 언어에 익숙한 프로그래머가 빠르게 학습할 수 있도록 설계되었다.
- 클래스는 함수이며, 기존 프로토타입 패턴을 클래스처럼 사용할 수 있게 해주는 문법적 설탕이지만, 단순한 설탕으로 볼 것이 아니라 새로운 객체 생성 메커니즘으로 봐야 한다.
- 클래스와 생성자 함수는 비슷하게 작동하지만, 클래스는 더 엄격하고 추가 기능을 제공한다.
    - **`new`** 없이 클래스를 호출하면 에러가 발생한다.
    - 클래스는 **`extends`**와 **`super`** 키워드를 제공해 상속을 간결하고 명확하게 한다.
    - 클래스는 호이스팅이 안 되는 것처럼 작동하며, **`strict mode`**가 기본적으로 적용된다.
    - 클래스의 생성자와 메서드는 열거되지 않는다.

## 25.2 클래스 정의

- 클래스는 **`class`** 키워드로 정의된다.
- 클래스 이름은 보통 파스칼 케이스(PascalCase)를 사용한다.
- 클래스는 함수처럼 표현식으로 정의할 수 있다:
    - 익명 클래스 표현식: **`const Person = class {};`**
    - 기명 클래스 표현식: **`const Person = class MyClass {};`**
- 클래스는 일급 객체의 특성을 가진다:
    - 런타임에 생성 가능한 무명 리터럴로서 정의될 수 있다.
    - 변수나 자료구조에 저장할 수 있다.
    - 함수의 매개변수로 전달할 수 있다.
    - 함수의 반환값으로 사용할 수 있다.
- 클래스 몸체에는 메서드만 정의할 수 있으며, 그 종류는 다음과 같다:
    - **`constructor`** (생성자)
    - 프로토타입 메서드
    - 정적 메서드
- 클래스와 생성자 함수는 유사한 정의 방식을 가지나, 클래스는 생성자 함수와 다르게 클래스 몸체에 정적 메서드와 프로토타입 메서드를 직접 정의할 수 있다.

## 25.3 클래스 호이스팅

- 클래스는 함수처럼 평가되고, **`typeof`**로 검사하면 **`function`**으로 나온다.
- 클래스 선언문은 런타임 이전에 평가되어 함수 객체를 생성하며, 이 때 생성된 함수 객체는 생성자 함수로 사용할 수 있는 **`constructor`**다.
- 클래스와 생성자 함수는 항상 쌍으로 존재한다. 함수 객체가 생성될 때 프로토타입 객체도 함께 생성된다.
- 클래스는 선언 전에 참조하면 **`ReferenceError`**가 발생한다. 이는 클래스가 **`let`**, **`const`**로 선언된 변수와 유사하게 TDZ에 빠지기 때문이다.
- 모든 식별자는 호이스팅되나, 클래스는 호이스팅이 되지 않는 것처럼 보이는 특별한 호이스팅 행동을 보인다.

## **25.4 인스턴스 생성**

- 클래스는 **`new`** 연산자와 함께 호출되어야 하며, 이는 인스턴스를 생성하는 유일한 방법이다.
- **`new`** 없이 클래스를 호출하면 **`TypeError`**가 발생한다.
- 기명 클래스 표현식으로 정의된 클래스의 이름은 클래스 몸체 내부에서만 유효하며, 외부 코드에서는 접근할 수 없다. 이름으로 직접 인스턴스를 생성하려고 하면 **`ReferenceError`**가 발생한다.

## 25.5 메서드

- 클래스 몸체에는 생성자, 프로토타입 메서드, 정적 메서드를 포함하여 0개 이상의 메서드만 선언할 수 있다.

### 25.5.1 constructor

![Untitled](25%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%2048cfae9cc2ec45708788725058d0b27f/Untitled.png)

- **`constructor`**는 클래스에서 인스턴스를 생성하고 초기화하기 위한 특수한 메서드이다.
- 클래스에 단 하나만 존재할 수 있으며, 이름을 변경할 수 없다.
- 인스턴스의 프로퍼티는 **`constructor`**에서 **`this`**를 사용해 추가한다.
- **`constructor`**는 생략 가능하며, 생략 시 빈 객체를 생성하는 빈 **`constructor`**가 암묵적으로 정의된다.
- 명시적으로 다른 객체를 반환하면 **`this`** 반환이 무시되고 해당 객체가 반환된다.
- 원시값을 반환하려 하면 반환은 무시되고 **`this`**가 반환된다.
- **`constructor`** 내에서 명시적으로 **`this`**가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손하므로 **`return`** 문을 사용해서는 안 된다.

### 25.5.2 프로토타입 메서드

**25.5.2 프로토타입 메서드**

생성자 함수를 사용해서 인스턴스를 생성할 때, 프로토타입 메서드를 추가하려면 명시적으로 프로토타입에 메서드를 추가해야 한다. 하지만 클래스를 사용할 경우, 클래스 몸체에서 정의한 메서드는 자동으로 프로토타입 메서드가 된다.

예를 들어, 다음과 같이 **`Person.prototype.sayHi`**를 정의하지 않고, 클래스 몸체 내에서 **`sayHi`** 메서드를 정의하면 이 메서드는 **`Person`**의 프로토타입 메서드가 된다:

![Untitled](25%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%2048cfae9cc2ec45708788725058d0b27f/Untitled%201.png)

클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 되며, 다음과 같은 관계를 가진다:

- **`me`** 객체의 프로토타입은 **`Person.prototype`**이다.
- **`Person.prototype`**의 프로토타입은 **`Object.prototype`**이다.
- **`me`** 객체의 **`constructor`**는 **`Person`** 클래스이다.

이러한 관계는 인스턴스가 프로토타입 메서드를 상속받아 사용할 수 있음을 의미한다. 프로토타입 체인은 객체 리터럴, 생성자 함수, **`Object.create`** 메서드 등 모든 객체 생성 방식과 마찬가지로 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다.

결국, 클래스는 생성자 함수와 같은 역할을 하는 프로토타입 기반의 객체 생성 메커니즘이다. 클래스는 생성자 함수의 또 다른 형태라고 볼 수 있다.

### 25.5.3 정적 메서드

정적 메서드란 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다.

생성자 함수의 경우 정적 메서드를 생성하기 위해서는 명시적으로 생성자 함수에 메서드를 추가해야 한다.

![Untitled](25%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%2048cfae9cc2ec45708788725058d0b27f/Untitled%202.png)

클래스에서는 static 키워드를 붙이면 정적 메서드가 된다.

![Untitled](25%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%2048cfae9cc2ec45708788725058d0b27f/Untitled%203.png)

**정적 메서드의 특징:**

- 클래스 정의가 평가되는 시점에 함수 객체로서 클래스가 생성되기 때문에, 인스턴스를 생성하지 않아도 바로 호출할 수 있다.
- 정적 메서드는 클래스에 바인딩된다.
- 인스턴스로는 정적 메서드를 호출할 수 없다. 이는 정적 메서드가 바인딩된 클래스가 인스턴스의 프로토타입 체인 상에 존재하지 않기 때문이다.

따라서, 정적 메서드는 프로토타입 메서드와 달리 클래스의 인스턴스가 아닌 클래스 자체에 속한 메서드로서, 인스턴스 없이 클래스 이름으로 직접 호출된다.

### **25.5.4 정적 메서드와 프로토타입 메서드의 차이**

정적 메서드와 프로토타입 메서드는 다음 기준으로 구분되며, 각각의 특징을 가진다:

1. **프로토타입 체인:** 정적 메서드와 프로토타입 메서드는 속해 있는 프로토타입 체인이 다르다.
2. **호출 방식:** 정적 메서드는 클래스를 통해 직접 호출되며, 프로토타입 메서드는 인스턴스를 통해 호출된다.
3. **인스턴스 프로퍼티 참조:** 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

### **결정 기준**

- **인스턴스 프로퍼티 참조 여부:** 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있으면 프로토타입 메서드로, 참조할 필요가 없으면 정적 메서드로 정의한다.
- **유틸리티 함수로의 사용:** 애플리케이션 전역에서 유틸리티 함수로 사용될 기능은 전역 함수로 정의하지 않고 클래스 또는 생성자 함수를 하나의 네임스페이로 사용하여 정적 메서드를 모아 놓으면 구조화 및 이름 충돌 방지의 효과를 얻는다.

이처럼, 메서드가 인스턴스의 상태에 의존하는지 여부와 전역적 유틸리티 함수로의 사용 여부를 고려하여 정적 메서드와 프로토타입 메서드 중 적절한 방식을 선택해야 한다.

### 25.5.5 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
3. 암묵적으로 strict mode로 실행된다.
4. for…in 문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며, 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다.
5. 내부 메서드 [[Construct]]를 갖기 않는 non-constructor다. 따라서 new 연산자와 함께 호출할 수 없다.

## **25.6 클래스의 인스턴스 생성 과정**

클래스로부터 인스턴스를 생성하는 과정은 **`new`** 연산자와 함께 클래스를 호출할 때 시작된다. 이 과정은 생성자 함수의 인스턴스 생성 과정과 유사하며, 주요 단계는 다음과 같다:

1. **인스턴스 생성과 this 바인딩:**
    - **`new`** 연산자와 함께 클래스를 호출하면, 먼저 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 생성되는 인스턴스다.
    - 생성된 인스턴스의 프로토타입은 클래스의 **`prototype`** 프로퍼티가 가리키는 객체로 설정된다.
    - 암묵적으로 생성된 인스턴스는 **`this`**에 바인딩된다. 따라서 **`constructor`** 내부의 **`this`**는 생성된 인스턴스를 가리킨다.
2. **인스턴스 초기화:**
    - **`constructor`** 내부 코드가 실행되며, **`this`**에 바인딩된 인스턴스를 초기화한다.
    - 인스턴스에 프로퍼티를 추가하고, **`constructor`**가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화한다.
    - **`constructor`**가 생략되면, 이 초기화 과정도 생략된다.
3. **인스턴스 반환:**
    - 모든 처리가 끝난 후, 완성된 인스턴스가 바인딩된 **`this`**가 암묵적으로 반환된다.

## 25.7 프로퍼티

### 25.7.1 인스턴스 프로퍼티

인스턴스 프로퍼티는 `constructor` 내부에서 정의해야 한다.

`constructor` 내부 코드가 실행되기 이전에 `constructor` 내부의 `this`에는 이미 클래스가 암묵적으로 생성한 인스턴스인 빈 객체가 바인딩되어 있다. 

**`constructor`** 내부의 **`this`**는 암묵적으로 생성된 인스턴스를 가리키며, 여기에 프로퍼티를 추가함으로써 인스턴스를 초기화한다.

인스턴스 프로퍼티는 기본적으로 **`public`**하다는 특징을 가지고 있어, 클래스 외부에서 자유롭게 접근할 수 있다. ES6의 클래스는 **`private`**, **`public`**, **`protected`**와 같은 접근 제한자를 기본적으로 지원하지 않지만, private 프로퍼티를 정의할 수 있는 사양이 제안 중이다.(지금은 모르겠습니다.)

### 25.7.2 접근자 프로퍼티

접근자 프로퍼티는 값이 아니라 접근자 함수 즉, getter와 setter 함수로 구성되며, 이를 통해 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용된다.

### 기본 개념

- **값을 직접 갖지 않음:** 접근자 프로퍼티는 자체적으로 값([[Value]] 내부 슬롯)을 갖지 않는다.
- **접근자 함수로 구성:** 대신 getter와 setter 함수로 구성되어 다른 프로퍼티의 값을 읽거나 저장한다.
- **프로퍼티 어트리뷰트:** `get`, `set`, `enumerable`, `configurable` 어트리뷰트를 갖는다.
- **인스턴스 vs 프로토타입 프로퍼티:** 클래스 내에서 정의된 접근자 프로퍼티는 프로토타입의 프로퍼티가 되며, 인스턴스를 통해 사용할 수 있다.
- **getter와 setter의 역할:**
    - **getter:** 프로퍼티를 참조할 때 내부 로직에 따라 값을 반환한다.
    - **setter:** 프로퍼티에 값을 할당할 때 내부 로직에 따라 값을 설정하거나 추가적인 작업을 수행한다.

접근자 프로퍼티는 프로퍼티의 값을 직접 변경하거나 참조하는 대신, 값을 읽거나 설정하는 과정에서 추가적인 로직을 실행할 필요가 있을 때 유용하다. 이를 통해 객체의 프로퍼티에 대한 더 세밀한 제어가 가능해진다.

### 25.7.3 클래스 필드 정의 제안

클래스 필드란 클래스 내에서 정의된 프로퍼티로, 클래스 기반 객체지향 언어에서 인스턴스가 소유할 프로퍼티를 말한다. 이는 클래스 내부에서 변수처럼 사용되며, 자바스크립트에서도 비슷한 개념을 사용할 수 있는 새로운 표준 사양이 제안되었다.

### 기본 개념:

- **클래스 필드:** 클래스가 생성할 인스턴스의 프로퍼티.
- **자바스크립트의 현재 상태:** 클래스 몸체에 메서드만 선언할 수 있으며, 클래스 필드를 직접 선언하면 문법 에러가 발생한다.

### 클래스 필드 정의 제안:

- 이 제안에 따르면, 자바스크립트에서도 클래스 몸체에 인스턴스 프로퍼티를 직접 선언하고 초기화할 수 있게 된다.
- TC39 프로세스의 stage 3(candidate)에 도달하여, 최신 브라우저(Chrome 72 이상)와 Node.js(버전 12 이상)에서는 이미 이 기능을 사용할 수 있다.

### 클래스 필드 사용:

- **정의 방법:** `constructor` 밖에서 클래스 필드를 정의할 수 있으며, `this`를 사용하지 않아도 된다.
- **초기값 할당:** 클래스 필드에 초기값을 할당하지 않으면 `undefined`가 된다.
- **외부 초기값 필요 시:** 인스턴스 생성 시 외부 초기값으로 클래스 필드를 초기화할 필요가 있다면, 여전히 `constructor` 내에서 초기화해야 한다.
- **함수 할당:** 함수를 클래스 필드에 할당할 수 있으나, 이 경우 인스턴스 메서드가 되므로 프로토타입 메서드 대신 사용하는 것은 권장되지 않는다.

### 결론:

클래스 필드 정의 제안은 자바스크립트에서 클래스 필드를 더 직관적으로 사용할 수 있게 해주며, 클래스 기반 객체지향 언어의 사용성을 높여준다. 하지만 인스턴스 생성 시 외부에서 초기값을 제공해야 하는 경우 `constructor`를 사용하는 기존 방법을 유지해야 한다. 이 제안은 인스턴스 프로퍼티를 정의하는 새로운 방법을 제공하지만, 클래스 설계 시 프로퍼티의 사용 목적과 접근 방식을 고려하여 적절한 방법을 선택해야 한다.

### **25.7.4 private 필드 정의 제안**

자바스크립트의 캡슐화와 정보 은닉 지원은 완전하지 않으며, ES6 클래스 역시 접근 제한자인 `private`, `public`, `protected`를 지원하지 않아 인스턴스 프로퍼티가 기본적으로 `public` 상태로 남는다. 그러나, 최신 표준 사양 제안으로, 클래스 내에서 `private` 필드를 정의할 수 있는 방법이 추가되었다.

### private 필드 정의 제안의 핵심 내용:

- **Stage 3:** TC39 프로세스의 stage 3(candidate)에 도달한 이 제안은 `private` 필드를 클래스 내부에서 정의하고 사용할 수 있도록 한다.
- **구현 상태:** 최신 브라우저(Chrome 74 이상)와 Node.js(버전 12 이상)에서 이미 구현되어 있다.

### private 필드 사용 방법:

- **선두에 #을 붙여 선언:** `private` 필드를 선언할 때는 필드 이름 앞에 `#`을 붙여준다.
- **클래스 내부에서만 접근 가능:** `private` 필드는 클래스 내부에서만 접근할 수 있으며, 클래스 외부나 인스턴스를 통한 직접 접근은 허용되지 않는다.
- **접근 가능성 비교:**
    
    ![스크린샷 2024-03-13 오전 12.25.51.png](25%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3%2048cfae9cc2ec45708788725058d0b27f/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_12.25.51.png)
    
- **접근자 프로퍼티를 통한 간접 접근:** `private` 필드에 직접 접근할 수는 없지만, 접근자 프로퍼티를 통해 간접적으로 접근하는 것은 가능하다.

### 주의사항:

- `private` 필드는 반드시 클래스 몸체에 정의해야 하며, `constructor` 내부에 직접 정의하려고 하면 에러가 발생한다.

이 제안으로 인해 클래스의 `private` 필드를 통해 정보 은닉과 캡슐화를 더욱 효과적으로 수행할 수 있게 되었다. 따라서, 애플리케이션의 안정성과 유지 보수성을 향상시킬 수 있다. `private` 필드와 함께 `public` 필드 및 접근자 프로퍼티를 적절히 활용하여 클래스 설계의 유연성을 높일 수 있다.

### 25.7.5 static 필드 정의 제안

 클래스에는 static 키워드를 사용하여 정적 메서드를 정의 할 수 있다. 하지만 static 키워드를 사용하여 정적 필드를 정의할 수는 없었다. 하지만 static public 필드, static private 필드, Static private 메서드를 정의할 수 있는 새로운 표준 사양인 "Static class features"가 TC39 프로세스의 stage 3(candidate)에 제안되어 있다. 이 제안 중에서 static public/private 필드는 최신 브라우저(Chrome 72 이상)와 최신 Node.js(버전12 이상)에 이미 구현되어 있다.

## 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속

상속에 의한 클래스 확장은 프로토타입 기반 상속과 본질적으로 다른 개념이다. 프로토타입 기반 상속은 객체 간의 속성을 공유하는 것이 주 목적이라면, 클래스 확장은 기존 클래스의 구조와 기능을 상속받아 새로운 클래스를 정의하는 것을 말한다.

### 클래스 상속:

- **extends 키워드 사용:** 클래스 상속에는 `extends` 키워드를 사용하며, 이는 상속받고자 하는 기존 클래스를 새로운 클래스에 확장하여 적용할 수 있도록 한다.

### 생성자 함수 상속:

- **문법적 지원 부재:** 생성자 함수는 클래스처럼 `extends`와 같은 상속을 위한 문법적 지원이 없다.
- **의사 클래스 상속 패턴:** 과거에는 생성자 함수 간에 상속을 구현하기 위해 의사 클래스 상속 패턴을 사용했다. 이 방법은 주로 프로토타입을 조작하여 부모 생성자 함수의 프로토타입을 자식 생성자 함수의 프로토타입 체인에 연결하는 방식을 사용했다.
- **필요성 감소:** ES6의 클래스 도입으로, 이전의 복잡한 상속 패턴을 대체할 수 있는 보다 간단하고 직관적인 방법이 제공되었다. 클래스의 `extends` 키워드를 사용하면, 상속 구현이 훨씬 용이해진다.

### 결론:

클래스와 생성자 함수는 모두 인스턴스를 생성할 수 있는 방법이지만, 클래스는 상속을 통해 기존의 코드를 재사용하고 확장하는 강력한 문법을 제공한다. 이로 인해 코드의 재사용성과 유지 보수성이 향상된다. 자바스크립트에서 클래스 상속은 코드 구조를 더욱 체계적으로 관리할 수 있게 해주며, 복잡한 객체 지향 프로그래밍 패턴을 실현할 수 있게 해준다. 생성자 함수를 사용한 상속 패턴은 이제 더 간편하고 직관적인 클래스 상속에 자리를 내주었다.

### 25.8.2 extends 키워드

`extends` 키워드를 사용하면 상속받을 클래스를 기반으로 새로운 클래스를 확장할 수 있다. 이 과정에서 확장된 클래스는 서브클래스라 불리며, 상속받은 기존의 클래스는 수퍼클래스로 명명된다. 다른 말로 서브클래스를 파생 클래스 또는 자식 클래스, 수퍼클래스를 베이스 클래스 또는 부모 클래스라고도 부른다.

`extends` 키워드의 주된 역할은 수퍼클래스와 서브클래스 사이의 상속 관계를 설정하는 것이다. 클래스 상속은 프로토타입을 기반으로 하며, 이를 통해 수퍼클래스와 서브클래스 간에 인스턴스 프로토타입 체인과 클래스 간의 프로토타입 체인을 생성한다. 결과적으로 프로토타입 메서드와 정적 메서드 모두 상속받을 수 있다.

### **25.8.3 동적 상속**

`extends` 키워드를 사용해 클래스는 물론, 생성자 함수도 상속받아 새로운 클래스를 확장할 수 있다. 이 과정에서 중요한 점은 `extends` 키워드 뒤에는 클래스나 [[Construct]] 내부 메서드를 가진 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다는 것이다. 이러한 특성 덕분에 상속받을 대상을 동적으로 결정할 수 있어, 상속 구조를 유연하게 구성할 수 있다.

### **25.8.4 서브클래스의 constructor**

서브클래스에서 `constructor`를 생략할 경우, 다음과 같은 `constructor`가 암묵적으로 정의된다:

```jsx
constructor(...args) {
    super(...args);
}

```

- `super()` 함수는 수퍼클래스의 `constructor`를 호출하여, 수퍼클래스의 인스턴스를 생성한다. 여기서 `...args`는 `new` 연산자와 함께 서브클래스를 호출할 때 전달한 인수들을 의미한다.
- 서브클래스에서 `constructor`를 명시적으로 정의할 경우, 반드시 `super()`를 호출해야 하며, 그렇지 않을 경우 오류가 발생한다. 이는 수퍼클래스의 인스턴스 초기화 로직을 보장하기 위함이다.

### **25.8.5 super 키워드**

`super`는 특수한 키워드로, 함수처럼 호출할 수도 있고 식별자처럼 참조할 수도 있다. 주로 수퍼클래스의 constructor와 메서드에 접근할 때 사용된다.

- **super 호출:** `super()`를 호출하면 수퍼클래스의 constructor를 호출해, 수퍼클래스로부터 상속받은 프로퍼티를 인스턴스에 추가한다. 서브클래스에서 `constructor`를 정의할 때는 `super()` 호출을 통해 수퍼클래스의 `constructor`에 인수를 전달할 수 있다.
- **super 참조:** 메서드 내에서 `super`를 참조하면 수퍼클래스의 메서드를 호출할 수 있다. 이를 통해 서브클래스는 수퍼클래스의 메서드를 재사용하거나 확장할 수 있다.

**주의사항:**

1. 서브클래스에서 `constructor`를 정의하고 `super()`를 호출하지 않으면 `this`를 참조할 수 없다.
2. `super`는 서브클래스의 `constructor`와 메서드에서만 유효하다. 다른 곳에서 사용하면 에러가 발생한다.
3. `super` 참조는 ES6 메서드 축약 표현으로 정의된 함수에서만 유효하며, `[[HomeObject]]`를 통해 수퍼클래스의 메서드에 접근한다.

`super` 사용은 클래스 상속 구조에서 중요한 역할을 하며, 상속받은 기능을 쉽게 활용하거나 확장할 수 있게 해준다.

### 25.8.6 상속 클래스의 인스턴스 생성 과정

상속 관계에 있는 클래스가 인스턴스를 생성하는 과정은 다음 단계로 이루어진다:

1. **서브클래스의 super 호출**: 서브클래스에서 `new` 연산자로 인스턴스 생성 시, 서브클래스의 `constructor`에서 `super()`를 호출하면 수퍼클래스의 `constructor`가 실행된다. 서브클래스는 직접 인스턴스를 생성하지 않고, 수퍼클래스에게 인스턴스 생성을 위임한다.
2. **수퍼클래스의 인스턴스 생성과 this 바인딩**: 수퍼클래스의 `constructor` 실행 전, 암묵적으로 빈 객체(인스턴스)가 생성되고 `this`에 바인딩된다. 생성된 인스턴스의 프로토타입은 `new.target`이 가리키는 서브클래스의 `prototype`이 된다.
3. **수퍼클래스의 인스턴스 초기화**: 수퍼클래스의 `constructor`에서 인스턴스에 프로퍼티를 추가하고 초기화한다.
4. **서브클래스 constructor로의 복귀와 this 바인딩**: `super` 호출이 끝나고 제어 흐름이 서브클래스의 `constructor`로 돌아온다. `super`가 반환한 인스턴스가 `this`에 바인딩된다.
5. **서브클래스의 인스턴스 초기화**: `super` 호출 후, 서브클래스의 `constructor` 내부에서 인스턴스 초기화가 진행된다. 이 단계에서 인스턴스에 새로운 프로퍼티를 추가하고 초기화할 수 있다.
6. **인스턴스 반환**: 모든 초기화 과정이 끝나면, 완성된 인스턴스가 암묵적으로 반환된다.

이 과정을 통해 수퍼클래스와 서브클래스는 협력하여 하나의 완성된 인스턴스를 생성한다. `super` 호출은 수퍼클래스의 `constructor`를 통해 인스턴스 생성 및 초기화를 수행하는 핵심 단계로, 서브클래스에서 인스턴스를 올바르게 생성하기 위해 반드시 필요하다.

### 25.8.7 표준 빌트인 생성자 함수 확장

표준 빌트인 생성자 함수(예: `Array`, `String`, `Number`)는 `[[Construct]]` 내부 메서드를 가지고 있어 `extends` 키워드를 사용해 확장할 수 있다. 이를 통해 표준 빌트인 객체의 기능을 상속받아 새로운 기능을 추가하거나 기존 기능을 변경하여 사용자 정의 클래스를 만들 수 있다.

예를 들어, `Array` 생성자 함수를 상속받아 확장한 `MyArray` 클래스를 만들 경우, `MyArray` 클래스로 생성된 인스턴스는 `Array.prototype`의 모든 메서드뿐만 아니라 `MyArray.prototype`의 메서드도 사용할 수 있다. 이런 방식으로 표준 빌트인 객체를 확장하면, 메서드 체이닝 같은 고급 기능을 구현할 때 유용하다.

하지만 주의해야 할 점은, `Array.prototype`의 메서드 중 새로운 배열을 반환하는 메서드(예: `map`, `filter`)가 `MyArray` 클래스의 인스턴스를 반환해야 한다는 것이다. 만약 이 메서드들이 `Array`의 인스턴스를 반환하면, `MyArray` 클래스의 메서드와 메서드 체이닝이 불가능해진다.

`MyArray` 클래스의 메서드가 `MyArray` 인스턴스를 반환하도록 하려면 `Symbol.species`를 사용해 정적 접근자 프로퍼티를 추가하는 방법이 있다. 이를 통해 새로운 배열을 반환하는 메서드가 `MyArray` 클래스의 인스턴스를 반환하도록 할 수 있으며, 이는 메서드 체이닝을 가능하게 한다.

결국, `extends` 키워드와 `Symbol.species`를 활용하면, 표준 빌트인 생성자 함수를 상속받아 확장하는 과정에서 발생할 수 있는 문제를 해결하고, 유연한 사용자 정의 클래스를 만들 수 있다.
