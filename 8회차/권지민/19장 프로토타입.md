# 📚 프로토타입

> 자바스크립트는 명령형, 함수형, 프로토타입 기반, 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.

> 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 "모든 것"이 객체다.


## 🎀 객체지향 프로그래밍
> 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.


```js
const circle = {
  // property
  radius: 5, // 반지름

  // method
  // 원의 지름: 2r
  getDiameter() {
    return 2 * this.radius;
  },

  // method
  // 원의 둘레: 2πr
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  },

  // method
  // 원의 넓이: πrr
  getArea() {
    return Math.PI * this.radius ** 2;
  }
};

console.log(circle);
// {radius: 5, getDiameter: ƒ, getPerimeter: ƒ, getArea: ƒ}

console.log(circle.getDiameter());  // 10
console.log(circle.getPerimeter()); // 31.41592653589793
console.log(circle.getArea());      // 78.53981633974483
```

1. 원의 반지름 속성은 상태를 나타내는 데이터이다.
2. 원의 지름, 둘레, 넓이를 구하는 것은 동작이다.

객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다.

즉, 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 구조를 가진다고 이야기할 수 있겠다.

## 🎀 상속과 포로토타입

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.

"생성자 함수"를 활용하여 동일한 프로퍼티를 가지는 객체를 여러개 생성할 수 있다.


```js
function 밍밍 (실명) {
    this.나이= 20;
    this.키= 172;
    this.실명=실명;
    this.sayHi = function(){
        return `안녕하세요 저는 밍밍이고 실명은 ${실명}입니다.`
    }
}

// 밍밍 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는
// 새로운밍밍 메서드를 중복 생성하고 중복 소유하게 된다.
var 새로운밍밍 = new 밍밍("권지민"); // 밍밍 {나이: 20, 키: 172, 실명: '권지민', sayHi: ƒ}
var 새로운밍밍2 = new 밍밍("권밍밍"); // 밍밍 {나이: 20, 키: 172, 실명: 'KwonJimin', sayHi: ƒ}
```

하지만 몇가지 문제가 존재한다.

1. 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다.
2. 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 준다.


상속을 통해 불필요한 중복을 제거해 보자.

```js
// 1. 우선 메서드 삭제
function 밍밍 (실명) {
    this.나이= 20;
    this.키= 172;
    this.실명=실명;
}

// 2. 프로토타입에다가 직접 메서드를 추가해 준다.
// 생성자 함수로 생성할때 공유 가능하다.
밍밍.prototype.sayHi = function (){
    return `안녕하세요 저는 밍밍이고 실명은 ${this.실명}입니다.`
}

// 3. 생성자 함수 생성
const 새로운밍밍 = new 밍밍("권지민")

console.log(새로운밍밍.sayHi()); // '안녕하세요 저는 밍밍이고 실명은 권지민입니다.'
```

실제로 새로 생성된 객체 "새로운밍밍"을 console에 찍어보면, sayHi라는 메서드가 존재하지 않는다.
```js
console.log(새로운밍밍); // 밍밍 {나이: 20, 키: 172, 실명: '권지민'}
```

하지만 프로퍼티에 상속되어져 있기 때문에 접근 가능한 것이다.
```js
console.log(밍밍.prototype); // {sayHi: ƒ, constructor: ƒ}
```

그래서 프로토타입을 "유전자"라고 이해하면 쉽다.

>눈에 보이진 않아도 수억 수천년동안 공유되어지고 있는 유전자와 같다.



## 🎀 프로토타입 객체


여기서의 "상속"은 "복사"의 의미가 아니다. 자바스크립트에서는 이 "복사" 의미를 가진 상속을 구현하기 위해서 `__proto__` 속성을 활용하게 된다.

> `__proto__`는 객체와 객체를 연결해 주는 링크를 의미한다.

### 📌 생성자 함수로 만들어진 객체인 경우
만들어진 새로운 객체의 `__proto__` 링크가 원래 객체의 `prototype`을 가리키게된다.

위의 코드로 예시를 들어 보면, 아래와 같다.
```js
// 새로 생성된 객체의 __proto__를 찍어보면
// 상속 받아온 밍밍 객체의 prototype이 출력된다.

// 새로 생성된 객체를 찍어보면 sayHi 메서드가 들어있지 않다.
console.log(새로운밍밍); // 밍밍 {나이: 20, 키: 172, 실명: '권지민'}

// 하지만 새로 생성도니 객체의 __proto__를 찍어보면 상속 받아온 객체인 "밍밍" 객체의 prototype을 가리키고 있기 때문에, sayHi 메서드가 출력된다.
console.log(새로운밍밍.__proto__); // {sayHi: ƒ, constructor: ƒ}
```

### 📌 프로토타입 체이닝

이런 현상이 가능한 이유는 `프로토타입 체이닝`이 일어나기 때문이다.

> 프로토타입 체이닝이란? Prototype을 찾기위해 __proto__ 링크를 따라 계속해서 탐색해 나가는 것을 의미한다.

```js
새로운밍밍.sayHi()
```

위 코드는 `새로운밍밍`이라는 객체에서 메서드를 호출하는 간단한 코드처럼 보인다.

하지만 사실 그 뒷편에서는 많은 일들이 일어나고 있다.

1. 우선 `새로운밍밍` 객체에서 `sayHi()` 메서드가 존재하는지 탐색한다.
2. 없다면 `__proto__`를 활용해서 `밍밍`의 `prototype` 접근하여 `sayHi()` 메서드를 탐색한다.
   - 그 곳에 메서드가 존재한다면? 오류없이 실행이 가능!
4. 만약 `밍밍`의 `prototype`에 `sayHi()` 메서드가 없다면
5. `__proto__`를 활용해서 `밍밍`을 만든 생성자 함수의 `prototype`에 접근하는 식으로 계속해서 프로토타입 체이닝이 지속된다.
6. `__proto__`가 존재하지 않는 `Object's prototype`에서 탐색을 멈추게 되고 `undefined`를 반환한다.

❗️ 모든 객체가 `__proto__` 를 사용할 수 있는 것은 아니기 때문에 직접 코드 내에서 사용하는 것은 권장되지 않는다.

## 🎀 프로토타입 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

📌 사용자 정의 생성자 함수와 프로토타입 생성 시점

- 생성자 함수로 호출할 수 있는 constructor는 함수 객체를 생성하는 시점에 더불어 프로토타입도 생성된다.
- 생성자 함수로 호출할 수 없는 non-constructor는 프로토타입이 생성되지 않는다.

📌 빌트인 생성자 함수와 프로토타입 생성 시점

Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.
