# 26장 함수의 추가 기능

## 26.1 함수의 구분

### **ES6 이전 자바스크립트 함수의 특징**

- 별다른 구분 없이 다양한 목적으로 사용됨.
- 모든 함수는 `callable`이면서 `constructor`
- 실수 유발 및 성능 면에서 손해 있음.

ex) 일반 함수로 호출 가능. **`new`** 연산자와 함께 생성자 함수로 호출하여 인스턴스 생성 가능. 객체에 바인딩되어 메서드로서 호출 가능.

### **ES6에서의 함수 구분 개선**

![스크린샷 2024-03-19 오전 11.49.35.png](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-19_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.49.35.png)

- 함수를 목적에 따라 세 가지로 구분: 일반 함수(Normal), 메서드(Method), 화살표 함수(Arrow)
- 일반 함수(함수 선언문, 함수 표현식으로 정의한 함수)는 기존과 동일하게 `constructor`.
- 메서드와 화살표 함수는 `non-constructor,` 즉, 생성자로 사용할 수 없음.
- 화살표 함수에는  `super`, `arguments` 도 사용 불가.

이로 인해 호출 방식이 명확해지고, 실수 및 성능 문제 감소.

## 26.2 메서드

- **ES6 이전의 메서드 정의**
    - 객체에 바인딩된 함수를 메서드라고 일컬었으나, 명확한 정의 부재.
    - 
- **ES6 메서드 정의**
    - 메서드 축약 표현으로 정의된 함수만을 메서드로 인정.
    - 인스턴스 생성 불가능(`non-constructor`).
    - 프로토타입 프로퍼티와 프로토타입 생성하지 않음.

- **ES6 메서드의 특성**
    - 인스턴스를 생성할 수 없는 `non-constructor`로 정의됨.
    - 생성자 함수로 호출할 수 없음.
    - `prototype` 프로퍼티가 없으며, 프로토타입도 생성하지 않음.(표준 빌트인 객체의 프로토타입 메서드와 정적 메서드 역시 `non-constructor`임.)
    - 내부 슬롯 `[[HomeObject]]`를 가짐, 이는 메서드가 자신을 바인딩한 객체를 가리키는 데 사용됨.
    - `super` 키워드 사용 가능: `[[HomeObject]]`를 통해 수퍼클래스의 메서드 참조 가능.(ES6 메서드만이 `super` 키워드를 사용할 수 있음.)

메서드 정의 시, ES6 이전 방식(프로퍼티 값으로 익명 함수 표현식을 할당) 대신 메서드 축약 표현 사용 권장. 

이는 메서드의 본연의 기능을 활용하고, 의미적으로 맞지 않는 기능을 제거하기 위함.

## 26.3 화살표 함수

### 화살표 함수 정의

**정의**: **`function`** 키워드 대신 **`=>`**를 사용해 간략하게 함수를 정의할 수 있음.

- **함수 정의**
    - 함수 선언문으로는 정의할 수 없고, 함수 표현식으로만 정의해야 함.
    
- **매개변수 선언**
    - 여러 개일 경우: **`(x, y) => { ... }`**
    - 한 개일 경우: **`x => { ... }`**, 소괄호 생략 가능
    - 없을 경우: **`() => { ... }`**, 소괄호 생략 불가
    
- **함수 몸체**:
    - 하나의 표현식으로 구성된 경우: **`{}`** 생략 가능하며 암묵적으로 반환됨. 예: **`x => x ** 2`**
    - 하나의 문이지만 표현식이 아닌 경우: **`{}`**를 생략할 수 없음. 표현식이 아닌 문은 반환할 수 없기 때문.
    - 객체 리터럴 반환 시: 객체 리터럴을 `**()**`로 감싸주어야 한다.
        
         **`() => ({ id: 1, content: "JavaScript" })`**
        
        소괄호로 감싸지 않으면 객체 리터럴의 `**{}**`를 함수 몸체를 감싸는 걸로 잘못 해석함.
        
    - 여러개의 문으로 구성된 경우: `**{}**` 생략 할 수 없음. 이때 반환값이 있다면 명시적으로 반환해야 함.
        
        ```jsx
        const sum (a,b) => {
        	const result = a + b;
        	return result;
        };
        ```
        

### **화살표 함수의 특징**

- **즉시 실행 함수로 사용 가능**: **`((name) => { ... })('Lee');`**
- **고차 함수 사용 시**: **`.map(v => v * 2)`** 처럼 간결하고 가독성이 좋음.
- **`this` 바인딩**: 화살표 함수 내부의 **`this`**는 전역 객체가 아닌, 화살표 함수를 감싸는 외부 함수의 **`this`**를 가리킴.

### 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없는 `non-constructor`다. 따라서 화살표 함수는 프로토타입 프로퍼티가 없고 프로토타입도 생성하지 않는다.
2. 중복된 매개변수 이름을 선언할 수 없다.
    
    ```jsx
    function normal(a, a) { return a + a; }
    
    const arrow = (a, a) => a + a; // SyntaxError
    ```
    
3. 화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new`, `target` 바인딩을 갖지 않는다.
    
    화살표 함수 내부에서 참조하면 스코프 체인을 통해 상위 스코프의 `this`, `arguments`, `super`, `new`, `target` 을 참조한다.
    
    만약 화살표 함수가 중첩되어 있다면 가장 가까운 상위 함수 중에 화살표 함수가 아닌 함수의 `this`, `arguments`, `super`, `new`, `target` 을 참조
    

### 화살표 함수의 this

화살표 함수가 일반 함수와 구별되는 가장 큰 특징은 `this` 다.

화살표 함수의 `this` 는 일반 함수의 `this` 와 다르게 동작하여 `콜백 함수 내부의 this가 외부의 this와 다르기 때문에 발생하는 문제`를 해결한다.

콜백 함수 내부의 this가 외부의 this와 다르기 때문에 발생하는 문제

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled.png)

- 일반 함수로서 호출되는 모든 함수 내부의 `this`는 전역 객체를 가리킨다.
- 동일한 조건에서 `strict mode`일 경우 내부의 `this`에는 `undefined`가 바인딩된다.(위의 예제에서는 class 내부의 코드는 모두 `strict mode`)

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%201.png)

- **반면 화살표 함수는 함수 자체의 `this` 바인딩이 없고, 상위 스코프의 `this`를 그대로 참조하여 위의 문제를 해결한다. 이를 `lexical this`라 한다.**

- 화살표 함수가 전역 함수라면 `this`는 전역 객체를 가리킨다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%202.png)

- 화살표 함수의 `this`는 `call`, `apply`, `bind`로 교체할 수 없고 언제나 상위 스코프의 `this`를 가리킨다.
- 메서드로 사용할 때 역시 화살표 함수의 `this`는 상위 스코프를 가리키므로 사용하지 않는 것이 좋다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%203.png)

- 대신 ES6 메서드 축약 표현을 사용하는 것이 좋다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%204.png)

- 프로퍼티를 동적으로 추가할 경우는 ES6 메서드 정의를 사용할 수 없으므로 일반 함수를 사용한다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%205.png)

- 클래스 필드에서 화살표 함수를 할당하면 프로토타입 메서드가 아닌 인스턴스 메서드가 되므로 ES6 메서드를 사용하는 것이 좋다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%206.png)

### 화살표 함수의 super

화살표 함수는 함수 자체의 `super` 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 `super`을 참조하면 `this` 와 마찬가지로 상위 스코프의 `super`을 참조한다.

- **`super` 키워드 사용 조건**
    
    **`super`**는 ES6 메서드 내에서만 사용할 수 있는데, 이는 메서드가 내부 슬롯 **`[[HomeObject]]`**를 가지고 있기 때문이다. **`[[HomeObject]]`**는 메서드가 속한 객체를 가리키며, **`super`**는 이를 통해 부모 클래스의 메서드를 호출할 수 있게 한다.
    
- **화살표 함수와 `super`**
    
    클래스 필드에 할당된 화살표 함수는 **`super`**를 직접적으로 가지고 있지 않지만, 에러 없이 **`super`**를 참조할 수 있다. 이 경우, 화살표 함수가 아니라 그 화살표 함수가 포함된 constructor의 **`super`** 바인딩을 참조하게 된다.
    
- **`this`와 `super`의 유사점**
    
    클래스 필드에 할당된 화살표 함수에서 **`this`**와 **`super`** 모두를 참조하면, 실제로는 그 화살표 함수를 감싸고 있는 constructor 내부의 **`this`** 및 **`super`** 바인딩을 참조하게 된다.
    

- **암묵적인 constructor 생성**
    
    클래스에 constructor를 명시적으로 선언하지 않았더라도, 자바스크립트는 암묵적으로 constructor를 생성한다. 이 암묵적 생성된 constructor는 부모 클래스의 constructor를 호출하는 **`super`** 호출을 포함한다.
    

### 화살표 함수의 arguments

화살표 함수는 함수 자체의 `arguments` 바인딩을 갖지 않는다.따라서 화살표 함수 내부에서 `arguments`을 참조하면 `this` 와 마찬가지로 상위 스코프의 `arguments`을 참조한다.

- **상위 스코프 참조의 한계**
    
    화살표 함수 자신에게 전달된 인수 목록은 확인할 수 없고, 오직 상위 함수에게 전달된 인수 목록만 참조할 수 있음. 
    

화살표 함수에서 **`arguments`** 객체를 직접적으로 사용할 수 없으므로, 화살표 함수로 가변 인자 함수를 구현하려면 반드시 Rest 파라미터를 사용해야 한다.

## 26.4 Rest 파라미터

### 기본 문법

**함수에 전달된 인수들의 목록을 배열로 전달받는다.**

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%207.png)

일반 매개변수와 같이 사용할 수 있다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%208.png)

먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들이 들어온다. 따라서 제일 마지막에 선언되어야한다.

Rest 파라미터는 length 프로퍼티에 영향을 주지 않는다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%209.png)

### Rest 파라미터와 arguments 객체

arguments 객체는 함수 호출 시 전달된 인수들의 정보가 담겨있는 유사 배열 객체.

함수 내부에서 지역 변수처럼 사용 가능.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%2010.png)

하지만 arguments 객체는 배열이 아닌 유사 배열 객체이므로 배열 메서드를 사용하려면 `call`이나 `apply` 메서드를 사용해 배열로 변환해야 하는 번거로움이 있다.

그에 반해 Rest 파라미터는 가변 인자 함수의 인수 목록을 배열로 직접 전달 가능.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%2011.png)

**화살표 함수는 함수 자체의 arguments가 없으므로 반드시 Rest 파라미터를 사용.**

## 26.5 매개변수 기본값

ES6에서 도입되었다.

함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 바람직하지만 그렇지 않은 경우에도 에러가 발생하지 않는다. 이는 자바스크립트 엔진이 매개변수의 개수와 인수의 개수를 체크하지 않기 때문

인수가 전달되지 않은 매개변수의 값은 `undefined`다. 이때 의도치 않은 결과가 발생할 수 있다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%2012.png)

따라서 매개변수에 기본값을 할당하는 방어 코드를 작성할 필요가 있다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%2013.png)

매개변수 기본값을 사용하면 간소화할 수 있다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%2014.png)

- Rest 파라미터에는 기본값을 지정할 수 없다.
- 매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 `length` 프로퍼티와 arguments 객체에 아무런 영향을 주지 않는다.

![Untitled](26%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8E%E1%85%AE%E1%84%80%E1%85%A1%20%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%20caab4cad7e3946ea90ef94e65190e86e/Untitled%2015.png)